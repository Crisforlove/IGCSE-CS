{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"IGCSE \u5b66\u4e60\u5168\u653b\u7565 \u5f85\u5b8c\u5584","text":"<p>\u540e\u7eed\u8865\u5145\uff1a</p> <ol> <li>\u5b8c\u558410\u7ae0\u8282\u5185\u5bb9\uff08\u57fa\u7840\u77e5\u8bc6+\u4f8b\u9898+\u56fe\u7247\u4e3e\u4f8b\uff09</li> <li>\u7d22\u5f15\u529f\u80fd\u5b8c\u5584\uff0c\u540e\u7eed\u94fe\u63a5\u5230\u6211\u4eec\u7684\u5fae\u4fe1\u516c\u4f17\u53f7\u6587\u7ae0\u548c\u89c6\u9891</li> <li>\u6848\u4f8b\u6301\u7eed\u4e30\u5bcc\uff0c\u5982\u4e00\u4e9b\u4e8c\u8fdb\u5236\u6e38\u620f\uff0c\u4e4b\u524d\u7684python\u5c55\u793a\u4ee3\u7801\uff0c\u540e\u7eed\u53ef\u4ee5\u4ee5\u94fe\u63a5\u6216\u8005\u7f51\u9875\u5c55\u793a\u7684\u5f62\u5f0f\u6765\u5e2e\u52a9\u5b66\u751f\u66f4\u597d\u7684\u7406\u89e3\u77e5\u8bc6\u70b9\u6982\u5ff5</li> <li>\u9898\u76ee\u7ec3\u4e60\u5b8c\u5584\uff0c\u540e\u7eed\u4e13\u9898\u8bad\u7ec3\u7b49\u7b49</li> <li>\u6301\u7eed\u8865\u5145ing</li> </ol> <p>\u76ee\u524d\u77e5\u8bc6\u70b9\u8865\u5145\u987a\u5e8f\u4e3a8-10\uff0c1-6\uff0c9</p> <p>\u5df2\u7ecf\u6709\u7684\u8d44\u6e90\uff1a</p> <ol> <li>\u80cc\u8bf5\u8bb0\u5fc6\u77e5\u8bc6\u70b9\uff0c\u8003\u5bdf\u5b66\u751f\u8bb0\u5fc6\u6027\u7684\u5185\u5bb9\uff0cpdf/docx\u7248</li> <li>\u4e13\u9898\u8bad\u7ec3chp 9\u548cchp 10\u7684\u90e8\u5206\uff0c\u76ee\u524d\u4ec5\u4e3adocx\u622a\u56fe\u683c\u5f0f\u548cpdf\u683c\u5f0f\uff0c\u540e\u7eed\u770b\u80fd\u4e0d\u80fd\u8f6c\u6210\u7f51\u9875\u7aef\u53ef\u5728\u7ebf\u7ec3\u4e60\u7684\u5176\u4ed6\u683c\u5f0f</li> </ol>"},{"location":"8%20Programming/8.1%20PROGRAMMING%20CONCEPTS/","title":"8.1 PROGRAMMING CONCEPTS","text":""},{"location":"8%20Programming/8.1%20PROGRAMMING%20CONCEPTS/#81-programming-concepts","title":"8.1 PROGRAMMING CONCEPTS","text":""},{"location":"8%20Programming/8.1%20PROGRAMMING%20CONCEPTS/#section-1-declare-and-use-variables-and-constants","title":"SECTION 1 | DECLARE AND USE VARIABLES AND CONSTANTS","text":"<p>What are Variables and Constants? Variables are named storage locations in your computer's memory that can hold different values throughout the execution of a program. Think of variables as containers that store information your program can use and modify.</p> <p>Constants are similar to variables but, once set, their value cannot change throughout the execution of your program. They are the \"constants\" in your coding equation, like the speed of light in physics.</p> <p>Declaring Variables and Constants To declare a variable or constant, you specify its type and give it a name. For example, in Python, you can declare a variable by simply typing age = 21. Here, age is a variable that stores the integer value 21.</p> <p>Declaring a constant in languages like Python involves naming conventions, such as all-uppercase letters with underscores separating words, e.g., MAX_SPEED = 120, because Python does not have a specific syntax for declaring constants.</p> <p>Why Use Them? Variables and constants make your code:</p> <ul> <li> <p>Readable | Using meaningful names makes your code easier to understand.</p> </li> <li> <p>Maintainable | Easy to update and modify your program.</p> </li> <li> <p>Reusable | Allows for the same code to be used with different data.</p> </li> <li> <p>Example declaring variables in Pseudocode</p> </li> <li> <p>integer_example \u2190 5</p> </li> <li>real_example \u2190 3.14</li> <li>char_example \u2190 'A'</li> <li>string_example \u2190 \"Hello, World\"</li> <li>boolean_example \u2190 TRUE</li> </ul> <p>### SECTION 2 | UNDERSTAND AND USE THE BASIC DATA TYPES</p> <p>Every piece of data in computer programs has a type. The basic data types include:</p> <ul> <li>Integer | Whole numbers, e.g., -10, 0, 25.</li> <li>Real | Numbers with fractional parts, also known as floating-point numbers, e.g., -3.14, 0.0, 2.72.</li> <li>Char |A single character, like 'a', 'B', or '3'.</li> <li>String | A sequence of characters, e.g., \"Hello, world!\".</li> <li>Boolean | Represents truth values, typically True or False. A Boolean can only be1 of a maximum of 2 values - True/False, On/Off, 1/0, Yes/No</li> </ul> <p>Choosing the Right Data Type   Selecting the appropriate data type is crucial for:</p> <ul> <li>Efficiency | Using the correct type makes your program run faster and use memory more efficiently.</li> <li>Accuracy | Ensures that the data is represented in a way that makes sense for the intended operation.</li> </ul> <p>### SECTION 3 | UNDERSTAND AND USE INPUT AND OUTPUT</p> <p>Input is how you get data from the user into your program. It can come from various sources like a keyboard, a file, or button press.</p> Python<pre><code>#INPUT Example - Asking a user for their age and storing it in a variable.\n\nage = input(\"Enter your age: \")\n\n#OUTPUT Example - Displaying a user's age.\nprint(\"Your age is\", age)\n</code></pre> Text Only<pre><code>OUTPUT \"Enter your age: \"\nINPUT age\nOUTPUT \"Your age is \", age\n</code></pre> <p>Importance of Input and Output</p> <ul> <li>Interaction | Allows your program to interact with users, making it dynamic and responsive.</li> <li>Data Processing | Enables your program to process user-provided data and produce results.</li> </ul>"},{"location":"8%20Programming/8.1%20PROGRAMMING%20CONCEPTS/#section-4-understand-and-use-the-concept-of-sequence","title":"SECTION 4 | UNDERSTAND AND USE THE CONCEPT OF SEQUENCE","text":"<p>Structured programming is a programming paradigm aimed at improving the clarity, quality, and development time of a computer program by making extensive use of subroutines, block structures, for loops, and if/else decision-making structures. This section covers two fundamental concepts: sequence and selection.</p> <p>A sequence in programming refers to the execution of instructions in the order they are written - from top to bottom in a script. This linear progression makes understanding the flow of a program straightforward.</p> Python<pre><code># Sequence Example\nprint(\"Start Program\")\nage = 20\nage = age + 1\nprint(\"Age next year:\", age)\nprint(\"End Program\")\n</code></pre> Text Only<pre><code>// Sequence Example\nOUTPUT \"Start Program\"\nage \u2190 20\nage \u2190 age + 1\nOUTPUT \"Age next year: \", age\nOUTPUT \"End Program\"\n</code></pre>"},{"location":"8%20Programming/8.1%20PROGRAMMING%20CONCEPTS/#section-4-understand-and-use-the-concept-of-selection","title":"SECTION 4 | UNDERSTAND AND USE THE CONCEPT OF SELECTION","text":"<p>Selection uses conditions to decide which pieces of code to execute. This decision-making process allows programs to take different actions based on inputs or other conditions. This examination board generally uses two different methods of selection, the 'IF' statement and the 'CASE' statement.</p> <p>IF STATEMENTS Usage:</p> <ul> <li>IF statements are used to execute a block of code if a specified condition is true. They can also include else and elif (else if) clauses to handle multiple conditions and outcomes.</li> <li>Ideal for complex conditions that involve logical operators (AND, OR, NOT) or comparisons that are not solely based on a single variable's value.</li> <li>Well-suited for scenarios where the conditions for decision-making are not exhaustive or cannot be easily enumerated.</li> </ul> <p>Characteristics:</p> <ul> <li>Flexibility in evaluating conditions that can be expressions involving variables, function calls, and logical operations.</li> <li>Can become cumbersome or less readable with many elif clauses, making code harder to follow.</li> <li>Directly supports execution of alternative blocks of code (else clause).</li> </ul> Python<pre><code># IF Statement Example\nscore = 75\nif score &gt;= 50:\n    print(\"You passed!\")\nelse:\n    print(\"Try again!\")\n</code></pre> Text Only<pre><code>// IF Statement Example\nscore \u2190 75\nIF score &gt;= 50 THEN\n    OUTPUT \"You passed!\"\nELSE\n    OUTPUT \"Try again!\"\nENDIF\n</code></pre> <p>CASE STATEMENTS (or Match Statements in Python 3.10+) Usage</p> <ul> <li>Used to select one of many blocks of code to execute, based on the value of a single variable.</li> <li>Ideal for when you have a variable that can take one out of a small set of possible values and you want to execute different code for each value.</li> <li>Makes code cleaner and more readable when dealing with multiple discrete values that a single variable can take.</li> </ul> <p>Characteristics</p> <ul> <li>More readable and concise for enumerated conditions (e.g., days of the week, specific known values).</li> <li>Cannot directly handle complex conditions involving logical operators across multiple variables without additional nesting or checks.</li> <li>Python's match statement supports pattern matching, which is more powerful than traditional CASE statements, allowing for matching types, sequences, and more.</li> </ul> Python<pre><code>number = 2    \nmatch number:\n        case 1:\n            print \"One\"\n        case 2:\n            print \"Two\"\n        case _:\n           print \"Something else\"\n</code></pre> Text Only<pre><code>// CASE Statement Example\nday_number \u2190 3\nCASE OF day_number\n    1: day \u2190 \"Monday\"\n    2: day \u2190 \"Tuesday\"\n    3: day \u2190 \"Wednesday\"\n    OTHERWISE: day \u2190 \"Unknown\"\nENDCASE\nOUTPUT \"Day is: \", day\n</code></pre> <p>DIFFERENCES</p> <ul> <li>Complexity of Conditions | IF statements are better for complex logical conditions, whereas CASE (or match) statements are ideal for checking one variable against a series of values.</li> <li>Readability | CASE statements can enhance readability when dealing with a clear enumeration of simple conditions. IF statements can become unwieldy with too many elif clauses but offer more flexibility in condition evaluation.</li> <li>Use Cases | Use IF statements when conditions are varied and involve multiple variables or complex logic. Use CASE statements for simpler, value-based decision paths on a single variable.</li> </ul> <p>Example - The below statement the below statement compares if the temperature is greater than 30, or less then 10, the else part of the statement would be used if it was any other value:</p> <p>temperature = 30 if temperature &gt; 30:   print(\"It's hot outside.\") elif temperature &lt; 10:   print(\"It's cold outside.\") else:   print(\"It's nice outside.\")</p> <p>Example - The below statement the below statement compares if the status_code is exactly one of the values stated.</p> <p>status_code = 404 match status_code:   case 200:     print(\"Success!\")   case 404:     print(\"Not Found.\")   case _:     print(\"Some other error.\") \u200b The choice between IF and CASE statements largely depends on the specific needs of your code, the complexity of the conditions you're evaluating, and the need for readability and maintainability of your code. Python's match statement adds extra versatility to the traditional concept of CASE statements, bridging some gaps between these two control flow mechanisms</p>"},{"location":"8%20Programming/8.1%20PROGRAMMING%20CONCEPTS/#section-5-understand-and-use-the-concept-of-iteration","title":"SECTION 5 | UNDERSTAND AND USE THE CONCEPT OF ITERATION","text":"<p>Iteration in programming refers to the repetition of a block of code as long as a specified condition is met. It's a fundamental concept that enables programs to perform tasks multiple times efficiently. There are three main types of loops used to implement iteration: count-controlled loops, pre-condition loops, and post-condition loops.</p> <p>Count-Controlled Loops Usage Count-controlled loops repeat a block of code a specific number of times. They are often used when the exact number of iterations is known ahead of time, such as processing each item in a fixed-size collection.</p> Python<pre><code># Looping through a range of numbers\nfor i in range(5):  # Repeats 5 times, from 0 to 4\n    print(\"This is count-controlled loop iteration\", i)\n</code></pre> Text Only<pre><code>FOR i \u2190 0 TO 4\n    OUTPUT \"This is count-controlled loop iteration \", i\nNEXT i\n</code></pre> <p>Pre-Condition Loops Usage Pre-condition loops (while loops) execute a block of code as long as a pre-defined condition is true. They are suitable when the number of iterations is not known before the loop starts, such as reading until an end-of-file marker is found.</p> Python<pre><code># Looping until a condition is met\ncount = 0\nwhile count &lt; 5:\n    print(\"This is pre-condition loop iteration\", count)\n    count += 1\n</code></pre> Text Only<pre><code>count \u2190 0\nWHILE count &lt; 5 DO\n    OUTPUT \"This is pre-condition loop iteration \", count\n    count \u2190 count + 1\nENDWHILE\n</code></pre> <p>Post-Condition Loops Usage Post-condition loops execute the loop body first and then check the condition to decide whether to continue. They guarantee that the loop body is executed at least once. This is useful in scenarios where the loop must execute at least once, such as displaying a menu and processing user input.</p> <p>Python Example: Python does not have a built-in post-condition loop construct, but you can mimic its behaviour using a while loop.</p> Python<pre><code># Simulating a post-condition loop\ncondition = False\nwhile True:\n    print(\"This loop runs at least once.\")\n    condition = input(\"Continue? (yes/no): \") != \"yes\"\n    if condition:\n        break\n</code></pre> Text Only<pre><code>REPEAT\n    OUTPUT \"This loop runs at least once.\"\n    INPUT condition, \"Continue? (yes/no): \"\nUNTIL condition \u2260 \"yes\"\n</code></pre> <p>Iterations are a powerful concept in programming, allowing for efficient repetition of code blocks. Count-controlled loops are ideal for a known number of iterations, pre-condition loops for uncertain iterations determined by conditions evaluated before entering the loop, and post-condition loops for scenarios where at least one iteration is required, with further iterations dependent on a condition checked after the loop's body executes</p> LOOP TYPE DESCRIPTION USE CASE PYTHON PSEUDOCODE Count-Controlled Iterates a specific number of times. When the number of iterations is known ahead of time for i in range(5): FOR i \u2190 0 TO 4 Pre-Condition Continues as long as a condition is true. When the number of iterations is not known before the loop starts. while condition: WHILE condition DO Post-Condition Executes at least once, then continues based on a condition. When the loop must run at least once and then continue based on a condition evaluated after each iteration. while True: with a break REPEAT ... UNTIL condition <p>This table highlights the key characteristics and use cases for each loop type, along with examples in both Python and the CIE pseudocode syntax.</p>"},{"location":"8%20Programming/8.1%20PROGRAMMING%20CONCEPTS/#section-6-understand-and-use-the-concepts-of-totalling-and-counting","title":"SECTION 6 | UNDERSTAND AND USE THE CONCEPTS OF TOTALLING AND COUNTING","text":"<p>In programming, \"totalling\" and \"counting\" are fundamental concepts used to aggregate or summarize data. \"Totalling\" involves summing up numbers to obtain a total, while \"counting\" refers to incrementally increasing a counter to track the quantity of items or occurrences. These concepts are crucial for data analysis, reporting, and decision-making processes in software applications.</p> <p>Totalling Totalling is the process of accumulating a sum over a set of numbers. This is commonly used in scenarios where you need to calculate the total score, the total amount of sales, or any other cumulative metric.</p> Python<pre><code># Calculating the total of a list of numbers\nnumbers = [10, 20, 30, 40]\ntotal = 0\nfor number in numbers:\n    total += number\nprint(\"Total is:\", total)\n</code></pre> Text Only<pre><code>numbers: ARRAY[1:4] OF INTEGER = [10, 20, 30, 40]\ntotal \u2190 0\nFOR i \u2190 1 TO 4\n    total \u2190 total + numbers[i]\nENDFOR\nOUTPUT \"Total is: \", total\n</code></pre> <p>Counting Counting involves incrementally updating a counter to track the number of occurrences of an event, such as counting the number of items that meet a specific condition.</p> Python<pre><code># Counting the number of even numbers in a list\nnumbers = [1, 2, 3, 4, 5, 6]\ncount = 0\nfor number in numbers:\n    if number % 2 == 0:\n        count += 1\nprint(\"Count of even numbers is:\", count)\n</code></pre> Text Only<pre><code>numbers: ARRAY[1:6] OF INTEGER = [1, 2, 3, 4, 5, 6]\ncount \u2190 0\nFOR i \u2190 1 TO 6\n    IF numbers[i] MOD 2 = 0 THEN\n        count \u2190 count + 1\n    ENDIF\nENDFOR\nOUTPUT \"Count of even numbers is: \", count\n</code></pre> <p>Differences and Use Cases Totalling is used when you need to accumulate a numeric value, such as calculating the sum of all elements in a list. It is often used in financial applications, statistical calculations, and anywhere you need to aggregate numeric data.</p> <p>Counting is used to determine the quantity of items that meet a specific criterion. This is useful in scenarios where you need to track occurrences, such as counting the number of passing grades, the number of positive reviews, or any condition-based metric.</p> <p>Both concepts are essential for data processing and analysis, enabling programmers to derive meaningful insights and metrics from data sets. Understanding how to implement totalling and counting effectively can greatly enhance a program's ability to process and summarize data.</p>"},{"location":"8%20Programming/8.1%20PROGRAMMING%20CONCEPTS/#section-7-understand-and-use-the-concept-of-string-handling","title":"SECTION 7 | UNDERSTAND AND USE THE CONCEPT OF STRING HANDLING","text":"<p>String handling involves manipulating text data in various ways, such as searching for substrings, converting between uppercase and lowercase, and extracting parts of strings. Effective string handling is crucial for data processing, user input manipulation, and many other programming tasks.</p> <p>Basic String Operations</p> <ul> <li>Length | Determine the length of a string.</li> <li>Substring | Extract a portion of a string.</li> <li>Concatenation | Join two or more strings together.</li> <li>Conversion | Change the case of a string (e.g., to uppercase or lowercase).</li> <li>Comparison |Compare two strings for equality or lexical order.</li> </ul> <p>Python Examples and Corresponding Pseudocode (CIE)</p> Python<pre><code>#LENGTH\nmy_string = \"Hello, World!\"\nprint(len(my_string))\n\n#SUBSTRING\nmy_string = \"Hello, World!\"\nprint(my_string[7:12])  \n#The output would be 'World'\n\n#CONCATENATION\ngreeting = \"Hello\"\nname = \"Alice\"\nmessage = greeting + \", \" + name + \"!\"\nprint(message)\n\n#CONVERSION\nmy_string = \"Hello, World!\"\nprint(my_string.upper())\nprint(my_string.lower())\n\n#COMPARISION\nstring1 = \"hello\"\nstring2 = \"world\"\nprint(string1 == string2)  # False\n</code></pre> Text Only<pre><code>#LENGTH\nmyString \u2190 \"Hello, World!\"\nOUTPUT LENGTH(myString)\n\n#SUBSTRING\nmyString \u2190 \"Hello, World!\"\nOUTPUT myString[7:12]\n#The output would be 'World'\n\n#CONCATENATION\ngreeting \u2190 \"Hello\"\nname \u2190 \"Alice\"\nmessage \u2190 greeting + \", \" + name + \"!\"\nOUTPUT message\n\n#CONVERSION\nmyString \u2190 \"Hello, World!\"\nOUTPUT TOUPPERCASE(myString)\nOUTPUT TOLOWERCASE(myString)\u200b\n\n#COMPARISION\nstring1 \u2190 \"hello\"\nstring2 \u2190 \"world\"\nIF string1 = string2 THEN\n    OUTPUT \"True\"\nELSE\n    OUTPUT \"False\"\nENDIF\n</code></pre> <p>String handling is a powerful tool in programming, enabling the manipulation and analysis of textual data. Understanding these basic operations\u2014length, substring extraction, concatenation, conversion, and comparison\u2014is essential for processing and utilising strings effectively in any programming task. The examples provided in both Python and pseudocode demonstrate how these operations can be implemented, showcasing the versatility and necessity of string handling in programming.</p>"},{"location":"8%20Programming/8.1%282%29%20PROGRAMMING%20CONCEPTS%20CONTINUED/","title":"8.1(2) PROGRAMMING CONCEPTS","text":""},{"location":"8%20Programming/8.1%282%29%20PROGRAMMING%20CONCEPTS%20CONTINUED/#812-programming-concepts-continued","title":"8.1(2) PROGRAMMING CONCEPTS CONTINUED","text":""},{"location":"8%20Programming/8.1%282%29%20PROGRAMMING%20CONCEPTS%20CONTINUED/#section-1-understand-and-use-arithmetic-logical-and-boolean-operators","title":"SECTION 1 | UNDERSTAND AND USE ARITHMETIC, LOGICAL AND BOOLEAN OPERATORS","text":"<p>This section covers the fundamental operators used in programming: arithmetic, logical, and Boolean operators. Operators are symbols that tell the compiler or interpreter to perform specific mathematical, logical, or relational operations and produce a final result.</p> <p>ARITHMETIC OPERATORS</p> <ul> <li>Addition (+) | Adds two operands. Example: 5 + 3 results in 8.</li> <li>Subtraction (-) | Subtracts the second operand from the first. Example: 5 - 3 results in 2.</li> <li>Division (/) | Divides the first operand by the second. Example: 10 / 2 results in 5.</li> <li>Multiplication (*) | Multiplies two operands. Example: 5 * 3 results in 15.</li> <li>Raised to the Power of (^) | Raises the first operand to the power of the second. Example: 2 ^ 3 results in 8.</li> <li>Modulus (MOD) | Returns the remainder of dividing the first operand by the second. Example: 10 MOD 3 results in 1.</li> <li>Integer Division (DIV) | Divides the first operand by the second, but returns only the integer part of the quotient. Example: 10 DIV 3 results in 3.</li> </ul> Python<pre><code>#Addition\nresult = 5 + 3\nprint(result)  # Outputs: 8\n\n#Subtraction\nresult = 5 - 3\nprint(result)  # Outputs: 2\n\n#Division\nresult = 10 / 2\nprint(result)  # Outputs: 5.0\n\n#Multiplication\nresult = 5 * 3\nprint(result)  # Outputs: 15\n\n#Raised to the power of\nresult = 2 ** 3  # In Python, ** is used for exponentiation\nprint(result)  # Outputs: 8\n\n#Modulus\nresult = 10 % 3  # In Python, % is used for modulus\nprint(result)  # Outputs: 1\n\n#Integer Division\nresult = 10 // 3  # In Python, // is used for integer division\nprint(result)  # Outputs: 3\n</code></pre> Text Only<pre><code>#Addition\nRESULT \u2190 5 + 3\nOUTPUT RESULT  // Outputs: 8\n\n#Subtraction\nRESULT \u2190 5 - 3\nOUTPUT RESULT  // Outputs: 2\n\n#Division\nRESULT \u2190 10 / 2\nOUTPUT RESULT  // Outputs: 5\n\n#Multiplication\nRESULT \u2190 5 * 3\nOUTPUT RESULT  // Outputs: 15\n\n#Raised to the power of\nRESULT \u2190 2 ^ 3\nOUTPUT RESULT  // Outputs: 8\n\n#Modulus\nRESULT \u2190 10 MOD 3\nOUTPUT RESULT  // Outputs: 1\n\n#Integer Division\nRESULT \u2190 10 DIV 3\nOUTPUT RESULT  // Outputs: 3\u200b\n</code></pre> <p>LOGICAL OPERATORS Logical operators are used to compare two values, depending on the operator used, it returns either True or False.</p> <ul> <li>Equal to (=) | Checks if two operands are equal. Example: 5 = 5 results in True.</li> <li>Less than (&lt;) | Checks if the first operand is less than the second. Example: 5 &lt; 8 results in True.</li> <li>Less than or equal to (&lt;=) | Checks if the first operand is less than or equal to the second. Example: 5 &lt;= 5 results in True.</li> <li>Greater than (&gt;) | Checks if the first operand is greater than the second. Example: 8 &gt; 5 results in True.</li> <li>Greater than or equal to (&gt;=) | Checks if the first operand is greater than or equal to the second. Example: 8 &gt;= 5 results in True.</li> <li>Not equal to (&lt;&gt;) | Checks if two operands are not equal. Example: 5 &lt;&gt; 8 results in True.</li> </ul> Python<pre><code>#Equal to \nprint(5 == 5)  # Outputs: True\n\n#Less than\nprint(5 &lt; 8)  # Outputs: True\n\n#Less than or equal to\nprint(5 &lt;= 8)  # Outputs: True\n\n#Greater than\nprint(5 &gt; 8)  # Outputs: False\n\n#Greater than or equal to\nprint(5 &gt;= 8)  # Outputs: False\n\n#Not equal to \nprint(5 != 8)  # In Python, != is used for not equal to\u200b\n</code></pre> Text Only<pre><code>#Equal to \nOUTPUT 5 = 5  // Outputs: TRUE\n\n#Less than\nOUTPUT 5 &lt; 8  // Outputs: TRUE\n\n#Less than or equal to\nOUTPUT 5 &lt;= 8  // Outputs: TRUE\n\n#Greater than\nOUTPUT 5 &gt; 8  // Outputs: FALSE\n\n#Greater than or equal to\n\u200bOUTPUT 5 &gt;= 8  // Outputs: FALSE\n#Not equal to \nOUTPUT 5 &lt;&gt; 8  // Outputs: TRUE\u200b\n</code></pre> <p>An example of the use of a logical operator could be:  IF 8 &gt;= 5 THEN   OUTPUT \"8 is greater than or equal to 5\" // Expected to output this message ELSE   OUTPUT \"8 is not greater than or equal to 5\" ENDIF</p> <p>BOOLEAN OPERATORS Boolean operators are used with Boolean values and expressions to make logical comparisons and decisions.</p> <ul> <li>AND | Returns True if both operands are true. Example: True AND False results in False.</li> <li>OR | Returns True if at least one of the operands is true. Example: True OR False results in True.</li> <li>NOT | Returns True if the operand is false, and vice versa. Example: NOT True results in False.</li> </ul> <p>Using AND *In the example below, we will check if a person is eligible to vote. A person is eligible if they are 18 years or older *and a citizen.</p> Python<pre><code>age = 20\ncitizen = True\n\nif age &gt;= 18 and citizen:\n    print(\"Eligible to vote.\")\nelse:\n    print(\"Not eligible to vote.\")\n</code></pre> Text Only<pre><code>AGE \u2190 20\nCITIZEN \u2190 TRUE\n\nIF AGE &gt;= 18 AND CITIZEN = TRUE THEN\n    OUTPUT \"Eligible to vote.\"\nELSE\n    OUTPUT \"Not eligible to vote.\"\nENDIF\n</code></pre> <p>Using OR Let's say a person is eligible to vote if they are 18 years or older or if they have a special permit, regardless of citizenship.</p> Python<pre><code>age = 17\nhas_special_permit = True\n\nif age &gt;= 18 or has_special_permit:\n    print(\"Eligible to vote with OR condition.\")\nelse:\n    print(\"Not eligible to vote with OR condition.\")\n</code></pre> Text Only<pre><code>AGE \u2190 17\nHAS_SPECIAL_PERMIT \u2190 TRUE\n\nIF AGE &gt;= 18 OR HAS_SPECIAL_PERMIT = TRUE THEN\n    OUTPUT \"Eligible to vote with OR condition.\"\nELSE\n    OUTPUT \"Not eligible to vote with OR condition.\"\nENDIF\n</code></pre> <p>Using NOT For this scenario, let's say a person is not eligible to vote if they are explicitly disqualified, even if they meet the age and citizenship requirements.</p> Python<pre><code>age = 20\ncitizen = True\ndisqualified = False\n\nif age &gt;= 18 and citizen and not disqualified:\n    print(\"Eligible to vote with NOT condition.\")\nelse:\n    print(\"Not eligible to vote with NOT condition.\")\n</code></pre> Text Only<pre><code>AGE \u2190 20\nCITIZEN \u2190 TRUE\nDISQUALIFIED \u2190 FALSE\n\nIF AGE &gt;= 18 AND CITIZEN = TRUE AND NOT DISQUALIFIED = TRUE THEN\n    OUTPUT \"Eligible to vote with NOT condition.\"\nELSE\n    OUTPUT \"Not eligible to vote with NOT condition.\"\nENDIF\n</code></pre>"},{"location":"8%20Programming/8.1%282%29%20PROGRAMMING%20CONCEPTS%20CONTINUED/#section-2-understand-and-use-nested-statements","title":"SECTION 2 | UNDERSTAND AND USE NESTED STATEMENTS","text":"<p>Nested statements in programming allow you to place one statement inside another. This can involve both selection (if-else) statements and iteration (loops) statements. Understanding how to effectively use nested statements is crucial for solving more complex problems where decisions are based on multiple conditions or tasks require multiple levels of looping.</p> <p>Nested Selection Nested selection involves placing if-else statements inside another if-else statement. This is particularly useful when decisions need to be made based on a series of conditions.</p> <p>Example Scenario: Suppose we want to determine if a movie is suitable for a viewer based on their age and a parent's permission.</p> Python<pre><code>age = 14\nparent_permission = True\n\nif age &gt;= 13:\n    if parent_permission:\n        print(\"You are allowed to watch the movie.\")\n    else:\n        print(\"You need a parent's permission to watch this movie.\")\nelse:\n    print(\"You are too young to watch this movie.\")\n</code></pre> Text Only<pre><code>AGE \u2190 14\nPARENT_PERMISSION \u2190 TRUE\n\nIF AGE &gt;= 13 THEN\n    IF PARENT_PERMISSION = TRUE THEN\n        OUTPUT \"You are allowed to watch the movie.\"\n    ELSE\n        OUTPUT \"You need a parent's permission to watch this movie.\"\n    ENDIF\nELSE\n    OUTPUT \"You are too young to watch this movie.\"\nENDIF\n</code></pre> <p>Nested Iteration Nested iteration involves placing a loop inside another loop. This technique is useful for working with multi-dimensional data structures or when a task requires repetitive actions within another set of repetitive actions.</p> <p>Nested Iteration Example: Team and Player Template Create a template that lists 4 teams, with each team having 6 players. This template can be used for organizing team rosters in sports or games.</p> Python<pre><code># Python code to iterate through teams and players\nfor team in range(1, 5):  # 4 teams\n    print(f\"Team {team}:\")\n    for player in range(1, 7):  # 6 players per team\n        print(f\"\\tPlayer {player}\")\n    print()  # Blank line after each team for better readability\n</code></pre> Text Only<pre><code>FOR TEAM \u2190 1 TO 4\n    OUTPUT \"Team \", TEAM, \":\"\n    FOR PLAYER \u2190 1 TO 6\n        OUTPUT \"\\tPlayer \", PLAYER\n    ENDFOR\n    OUTPUT \"\"  // Blank line after each team for better readability\nENDFOR\n</code></pre> <p>Explanation</p> <ul> <li>Outer Loop (Teams) | Iterates from 1 to 4, representing the 4 teams.</li> <li>Inner Loop (Players) | For each team, iterates from 1 to 6, representing the 6 players in each team.</li> <li>Output | The structure outputs the team number followed by a list of player numbers, using tabulation (\\t in Python or represented similarly in pseudocode) for indentation to clearly denote the players belonging to each team.</li> </ul> <p>This example illustrates the practical application of nested loops to organize and present hierarchical data in a structured format. By adjusting the range values in the loops, this approach can be easily adapted to different numbers of teams and players, showcasing the flexibility and utility of nested iteration in programming</p> <p>Limitations on Nesting While nesting can be powerful, it's important not to overcomplicate your code. For this syllabus, candidates are not required to write more than three levels of nested statements. This limitation helps keep the code more readable and manageable.</p> <p>Nested statements, both selection and iteration, allow for complex decision-making and data processing. By carefully structuring these nested statements, programmers can tackle complex problems while keeping their code efficient and understandable. Remember, the key to effectively using nested statements is to keep your logic clear and avoid unnecessary complexity.</p>"},{"location":"8%20Programming/8.1%282%29%20PROGRAMMING%20CONCEPTS%20CONTINUED/#section-3-procedures-functions-and-parameters","title":"SECTION 3 | PROCEDURES, FUNCTIONS AND PARAMETERS","text":"<p>In programming, procedures and functions are fundamental concepts that allow for code reuse, modularity, and improved readability. Both are blocks of code that perform a specific task, but they have a key difference in how they are used and the value they return.</p> <p>What is Meant by Procedures, Functions, and Parameters</p> <ul> <li>Procedures | A procedure is a block of code that performs a specific action but does not return a value to the caller. It is executed when called and is used to encapsulate code for tasks that need to be performed multiple times throughout a program.</li> <li>Functions | A function, like a procedure, is a block of code that performs a specific task, but it returns a value to the caller. Functions can be used to perform calculations, process data, and then return the result of that process.</li> <li>Parameters | Both procedures and functions can accept parameters (also known as arguments), which are pieces of data passed into them. These parameters allow procedures and functions to operate on different data without being rewritten for each unique case. Parameters make procedures and functions more versatile and adaptable.</li> </ul> <p>Below is an example of a procedure without any parameters</p> Python<pre><code>def display_message():\n    print(\"Hello from a procedure!\")\n\n# Calling the procedure\ndisplay_message()\n</code></pre> Text Only<pre><code>PROCEDURE DisplayMessage\n    OUTPUT \"Hello from a procedure!\"\nENDPROCEDURE\n\nCALL DisplayMessage\n</code></pre> <p>Below is an example of a procedure with Parameters</p> Python<pre><code>def greet_user(username):\n    print(f\"Hello, {username}!\")\n\n# Calling the procedure with a parameter\ngreet_user(\"Alice\")\n</code></pre> Text Only<pre><code>PROCEDURE GreetUser(Username)\n    OUTPUT \"Hello, \", Username, \"!\"\nENDPROCEDURE\n\nCALL GreetUser(\"Alice\")\n</code></pre> <p>Below is an example of a function without Parameters</p> Python<pre><code>def get_magic_number():\n    return 42\n\n# Calling the function and printing its return value\nprint(get_magic_number())\n</code></pre> Text Only<pre><code>FUNCTION GetMagicNumber\n    RETURN 42\nENDFUNCTION\n\nOUTPUT GetMagicNumber()\n</code></pre> <p>Below is an example of a function with Parameters</p> Python<pre><code>def add_numbers(number1, number2):\n    return number1 + number2\n\n# Calling the function with two parameters\nresult = add_numbers(5, 7)\nprint(result)\n</code></pre> Text Only<pre><code>FUNCTION AddNumbers(Number1, Number2)\n    RETURN Number1 + Number2\nENDFUNCTION\n\nRESULT \u2190 AddNumbers(5, 7)\nOUTPUT RESULT\n</code></pre> <p>Understanding and utilising procedures and functions with or without parameters is crucial for creating structured, reusable, and efficient code. While procedures perform tasks without returning a value, functions perform tasks and return a value, making both essential for modular programming. Parameters add flexibility, allowing these blocks of code to work with various data inputs.</p>"},{"location":"8%20Programming/8.1%282%29%20PROGRAMMING%20CONCEPTS%20CONTINUED/#section-4-global-and-local-variables","title":"SECTION 4 | GLOBAL AND LOCAL VARIABLES","text":"<p>Variables in programming are used to store data that your program can manipulate. The scope of a variable determines where it can be accessed within your code. This leads us to the distinction between local and global variables, which is fundamental for managing data flow and avoiding unintended side effects in your programs.</p> <p>Local Variables Local variables are declared inside a procedure or function and can only be accessed within that block. Their scope is limited to the block of code where they are defined, making them invisible to the rest of the program. This encapsulation helps in preventing conflicts and errors in large programs.</p> <p>Advantages</p> <ul> <li>Encapsulation | Keeps variables confined to the function or procedure, avoiding naming conflicts. This is especially important when large teams of programmers are working on the same project.</li> <li>Memory Efficiency | Memory used by local variables is freed once the block of code (function or procedure) finishes executing.</li> </ul> Python<pre><code>def calculate_sum(a, b):\n    result = a + b  # 'result' is a local variable\n    return result\n\nprint(calculate_sum(5, 7))\n# print(result)  # This would raise an error, as 'result' is not accessible here\n</code></pre> Text Only<pre><code>FUNCTION CalculateSum(A, B)\n    RESULT \u2190 A + B  // 'RESULT' is a local variable\n    RETURN RESULT\nENDFUNCTION\n\nOUTPUT CalculateSum(5, 7)\n// OUTPUT RESULT  // This would be incorrect, as 'RESULT' is not accessible here\n</code></pre> <p>Global Variables Global variables are declared outside any procedure or function and can be accessed and modified by any part of the program. While they offer convenience for small scripts or when sharing data between multiple functions, they should be used judiciously.</p> <p>Advantages</p> <ul> <li>Accessibility | Can be accessed from any part of the program, useful for shared data.</li> <li>Persistence | Retains value throughout the program execution, useful for data that needs to be accessed or modified by multiple functions.</li> </ul> <p>Disadvantages</p> <ul> <li>Risk of Unintended Modification | Can lead to bugs that are hard to track since any part of the program can change the variable.</li> <li>Reduced Clarity | Makes it harder to track the flow of data within the program.</li> </ul> Python<pre><code>global_number = 10  # 'global_number' is a global variable\n\ndef modify_global_number():\n    global global_number\n    global_number += 5\n\nmodify_global_number()\nprint(global_number)  # Outputs: 15\n</code></pre> Text Only<pre><code>GLOBAL_NUMBER \u2190 10  // 'GLOBAL_NUMBER' is a global variable\n\nPROCEDURE ModifyGlobalNumber\n    GLOBAL GLOBAL_NUMBER\n    GLOBAL_NUMBER \u2190 GLOBAL_NUMBER + 5\nENDPROCEDURE\n\nCALL ModifyGlobalNumber\nOUTPUT GLOBAL_NUMBER  // Outputs: 15\n</code></pre> <p>Understanding the distinction between local and global variables is crucial for writing clear, maintainable, and error-free code. Local variables provide encapsulation and are preferred for data that does not need to be shared across different parts of the program. Global variables offer convenience for shared data but come with risks of unintended modifications and should be used sparingly to maintain the integrity of your program's logic.</p>"},{"location":"8%20Programming/8.1%282%29%20PROGRAMMING%20CONCEPTS%20CONTINUED/#section-5-understand-and-use-library-routines","title":"SECTION 5 | UNDERSTAND AND USE LIBRARY ROUTINES","text":"<p>Library routines are pre-written functions or procedures provided by a programming language's standard library or external libraries. These routines offer convenient ways to perform common tasks without the need to reimplement them. Some library routines are built in and some you may need to import. Understanding how to use these routines can significantly speed up development time and ensure more reliable and efficient code.</p> <p>In this section, we will discuss the use of several common library routines: MOD, DIV, ROUND, and RANDOM.</p> <p>MOD The MOD routine calculates the remainder of a division operation between two numbers. For example 10 divided by 3 is 3 remainder 1, MOD just returns the remainder.</p> Python<pre><code>remainder = 10 % 3  # Using the modulus operator for MOD\nprint(remainder)  # Outputs: 1\n</code></pre> Text Only<pre><code>REMAINDER \u2190 10 MOD 3\nOUTPUT REMAINDER  // Outputs: 1\n</code></pre> <p>DIV The DIV routine performs integer division between two numbers, discarding any fractional part.</p> Python<pre><code>result = 10 // 3  # Using the floor division operator for DIV\nprint(result)  # Outputs: 3\n</code></pre> Text Only<pre><code>RESULT \u2190 10 DIV 3\nOUTPUT RESULT  // Outputs: 3\n</code></pre> <p>ROUND The ROUND routine rounds a floating-point number to the nearest whole number or to a specified number of decimal places.</p> Python<pre><code>rounded_number = round(3.14159, 2)  # Rounds to 2 decimal places\nprint(rounded_number)  # Outputs: 3.14\n</code></pre> Text Only<pre><code>ROUNDED_NUMBER \u2190 ROUND(3.14159, 2)\nOUTPUT ROUNDED_NUMBER  // Outputs: 3.14\n</code></pre> <p>RANDOM The RANDOM routine generates a random number. The specifics can vary; for example, you might generate a random number within a range.</p> Python<pre><code>import random\n\nrandom_number = random.randint(1, 10)  # Generates a random number between 1 and 10\nprint(random_number)\n</code></pre> Text Only<pre><code>// Assuming a RANDOM function that takes a range and returns an integer\nRANDOM_NUMBER \u2190 RANDOM(1, 10)\nOUTPUT RANDOM_NUMBER\n</code></pre> <p>WHY USE LIBRARY ROUTINES Library routines like MOD, DIV, ROUND, and RANDOM are essential tools in a programmer's toolkit, allowing for the efficient implementation of common mathematical and randomization tasks. By leveraging these routines, developers can write less code, reduce the likelihood of errors, and improve the readability and maintainability of their programs. Understanding how to use these routines is crucial for efficient programming and solving a wide array of problems.</p>"},{"location":"8%20Programming/8.1%282%29%20PROGRAMMING%20CONCEPTS%20CONTINUED/#section-6-understand-how-to-create-a-maintainable-program","title":"SECTION 6 | UNDERSTAND HOW TO CREATE A MAINTAINABLE PROGRAM","text":"<p>Creating maintainable programs is crucial for ensuring that code can be easily understood, updated, and extended by others, including your future self. Key practices that contribute to maintainability include the use of meaningful identifiers, effective commenting, and the structured use of procedures and functions. Below, we explore these aspects in detail.</p> <p>Meaningful Identifiers Meaningful identifiers make your code readable and self-explanatory. They are names given to variables, constants, arrays, procedures, and functions that describe their purpose or the data they hold.</p> <ul> <li>Variables | Use names that describe the data or purpose, such as userAge or totalAmount.</li> <li>Constants | Name constants in a way that indicates their unchangeable value, like MAX_SIZE or INTEREST_RATE.</li> <li>Arrays | Choose names that reflect the collection they represent, for instance, studentGrades or productPrices.</li> <li>Procedures and Functions | Their names should describe the action they perform or the result they return, such as calculateTotal or findMaximum.</li> </ul> <p>The Commenting Feature Comments are not executed as part of the program but serve as notes to the programmer and others who may work on the code later. They explain what the code does, why certain decisions were made, and can outline complex logic.</p> <ul> <li>Inline Comments | Used to describe specific lines of code or logic. Place them at the end of the line they refer to.</li> <li>Block Comments | Used for providing descriptions at the start of functions or major sections of code, explaining the overall purpose or behaviour.</li> </ul> <p>Procedures and Functions Organising code into procedures and functions is crucial for abstraction, code reuse, and reducing redundancy. They allow for compartmentalizing code into logical units that can be easily tested and debugged.</p> <ul> <li>Encapsulation | Group related logic into functions and procedures to hide complexity and make the main program flow clear and concise.</li> <li>Modularity | Break down the program into smaller, manageable pieces that can be developed and tested independently.</li> </ul> <p>Relevant and Appropriate Commenting of Syntax While meaningful identifiers can make the code self-explanatory to some extent, complex logic or unusual solutions may require additional explanation. Commenting becomes crucial in these scenarios.</p> <ul> <li>Why, not what | Focus on explaining why a certain approach was taken, not what the code does (which should be apparent from the code itself and meaningful identifiers).</li> <li>Updates and Changes | When modifying code, update or add comments to reflect changes, especially if the logic or purpose of the code has evolved.</li> </ul> Python<pre><code>#MEANINGFUL IDENTIFIERS - Good practice\nmonthlySalary = 3000\ninterestRateAnnual = 0.05\n\n#MEANINGFUL IDENTIFIERS - Poor practice\na = 3000  # It's not clear what this represents\nb = 0.05  # Ambiguous\n\n# COMMENTING\n# Calculate yearly interest\n# Using compound interest formula for annual compounding\nyearlyInterest = principalAmount * (1 + interestRateAnnual)\n\n#BLOCK COMMENTING\ndef calculateYearlyInterest(principal, rate):\n    \"\"\"\n    Calculate the yearly interest.\n    Parameters:\n    - principal: The principal amount.\n    - rate: The annual interest rate. \n    Returns:\n    The interest amount for one year.\n    \"\"\"\n    return principal * rate\n</code></pre> Text Only<pre><code>#MEANINGFUL IDENTIFIERS - Good practice\nMonthlySalary \u2190 3000\nInterestRateAnnual \u2190 0.05\n\n#MEANINGFUL IDENTIFIERS - Poor practice\na \u2190 3000  // It's not clear what this represents\nb \u2190 0.05  // Ambiguou\n\n# COMMENTING\n// Calculate yearly interest using compound interest formula for annual compounding\nYearlyInterest \u2190 PrincipalAmount * (1 + InterestRateAnnual)\n\n#BLOCK COMMENTING\n// Procedure to calculate yearly interest\nPROCEDURE CalculateYearlyInterest(Principal, Rate)\n    /*\n    Calculate the yearly interest.\n    Parameters:\n    - Principal: The principal amount.\n    - Rate: The annual interest rate. \n    Returns:\n    The interest amount for one year.\n    */\n    RETURN Principal * Rate\nENDPROCEDURE\n</code></pre> <p>Creating a maintainable program involves thoughtful naming, systematic organization, and clear documentation of your code. These practices not only make the code easier to understand and modify but also facilitate collaboration and ensure the longevity of your software projects</p> <p>SAMPLE PROGRAMMING QUESTION</p> <p>The names of students are stored in a one-dimensional (1D) array Student[] of type string. A separate two-dimensional (2D) array Scores[] stores the latest test scores for each student. The array already contains the scores for each student in two subjects: Math and English.</p> <ul> <li>Math scores should be in the range 0 to 100 inclusive.</li> <li>English scores should be in the range 0 to 100 inclusive.</li> <li>The student ID given to each student is used as the index for both arrays, and this is a value between 1 and 100 inclusive.</li> </ul> <p>When the data for a student is checked, a warning is given if any of the scores are out of range. If both scores are out of range, a severe warning is given.</p> <p>Write a function, using pseudocode or program code, that meets the following requirements:</p> <ul> <li>Takes the student ID as a parameter.</li> <li>Checks if the ID is valid.</li> <li>Returns an error message if the ID is not valid.</li> <li> <p>If the ID is valid:</p> </li> <li> <p>Returns the student\u2019s name.</p> </li> <li>Returns \"Scores are valid\" if both scores are within range.</li> <li>Returns \"Warning: Math score out of range\" or \"Warning: English score out of range\" if one score is out of range.</li> <li>Returns \"Severe warning: Both Math and English scores out of range\" if both scores are out of range.</li> </ul> <p>You must use pseudocode or program code and add comments to explain how your code works. You do not need to initialize the data in the arrays.</p>"},{"location":"8%20Programming/8.2%20ARRAYS/","title":"8.2 ARRAYS","text":""},{"location":"8%20Programming/8.2%20ARRAYS/#82-arrays","title":"8.2 | ARRAYS","text":""},{"location":"8%20Programming/8.2%20ARRAYS/#section-1-what-is-an-array","title":"SECTION 1 | WHAT IS AN ARRAY","text":"<p>An array is a collection of elements, each identified by at least one array index or key. Arrays can store data of the same type and are useful for organising data systematically for easy access and manipulation. </p> <p>They are just like the normal variables except they can hold multiple items of data and like variables they have the same naming conventions such as:</p> <p>NAMING RULES \u2718 Cannot start the name with a number \u200b\u2718 Cannot contain spaces \u200b\u2718 Cannot use command words such as print, python, turtle, exit, for, while and many more...</p> <p>NAMING CONVENTIONS \u2713Should start with a lowercase letter \u2713If more than one word used the first letter uppercase of proceeding words or use _ to join words \u200b\u2713Names should be meaningful to the content of the variable</p>"},{"location":"8%20Programming/8.2%20ARRAYS/#section-2-types-of-arrays","title":"SECTION 2 | TYPES OF ARRAYS","text":"<p>One-dimensional (1D) Arrays A one-dimensional array is a linear list of elements that are of the same type and are accessed by a single index. This type of array is simple and efficient for storing data that naturally forms a sequence.</p> <ul> <li>Example Use | A common use of 1D arrays is to store a list of items like user names or a series of numerical values such as test scores.</li> <li>Sample Array for a Scenario | Imagine you're managing a small music concert and need to keep track of the names of bands performing:</li> </ul> <p>bands = [\"The Foo Bar\", \"Baz Quux\", \"Quuz Corge\"]</p> <p>Two-dimensional (2D) Arrays A two-dimensional array, often called a matrix, is an array of arrays where each entry in the main array can hold another array. This setup allows for a grid-like structure, which is excellent for more complex data organizations that require accessing elements via two indices (rows and columns).</p> <ul> <li>Example Use | 2D arrays are useful for applications such as creating game boards, spreadsheets, or storing data in table form, where each row could represent a record and each column a type of information about that record.</li> <li>Sample Array for a Scenario | Suppose you are a teacher recording grades in different subjects for a class of three students. Each row represents a student, and each column represents a different subject.</li> </ul> <p>grades = [  [87, 92, 78], # Grades for Student 1  [91, 85, 90], # Grades for Student 2  [88, 84, 82]  # Grades for Student 3</p>"},{"location":"8%20Programming/8.2%20ARRAYS/#section-3-declaring-arrays","title":"SECTION 3 | DECLARING ARRAYS","text":"<p>Declaring an array involves specifying its type and the number of elements it will hold. This process can vary significantly between programming languages. Below, we expand on how to declare one-dimensional (1D) and two-dimensional (2D) arrays in both Python and using the CIE pseudocode conventions.</p> <p>DECLARING 1D ARRAYS</p> Python<pre><code>To declare a one-dimensional array in Python, which is typically done using lists, you simply assign a list of elements to a variable. Here, the elements can be of any type: strings, numbers, or even other lists.\n\n# Declaring a 1D array with string elements\nfruits = [\"apple\", \"banana\", \"cherry\"]\n\n# This creates a list of fruits with three elements.\n</code></pre> Text Only<pre><code>In the CIE pseudocode, an array must be explicitly declared with its size and type, which makes it clearer how many items the array can hold and what type they are.\n\n# Declare an array 'fruits' capable of holding three strings, indexed from 1 to 3.\nDECLARE fruits : ARRAY[1:3] OF STRING\n\n# Assign values to each position in the array.\nfruits[1] \u2190 \"apple\"\nfruits[2] \u2190 \"banana\"\nfruits[3] \u2190 \"cherry\"\n</code></pre> <p>DECLARING 2D ARRAYS</p> <p>A two-dimensional array in Python is essentially a list of lists. Each sublist represents a row in the array.</p> <p>Imagine a classroom with three students and their grades in three different subjects (Math, Science, English). It would be logical to arrange of data in rows and columns, as you would expect to see if you put the data in a spreadsheet. Here we create a 2D array in Pseudocode an Python with the same row and column structure.</p> Python<pre><code># Declaring a 2D array to store grades for three students in three subjects\ngrades = [\n  [85, 90, 88],  # Grades for Student 1: Math, Science, English\n  [78, 92, 80],  # Grades for Student 2: Math, Science, English\n  [90, 85, 87]   # Grades for Student 3: Math, Science, English\n]\n# This creates a table-like structure where each row represents a student and each column a subject.\n</code></pre> Text Only<pre><code># Declare a 2D array 'grades' with 3 rows and 3 columns, each cell to hold an integer representing a grade.\nDECLARE grades : ARRAY[1:3, 1:3] OF INTEGER\n\n# Assigning grades\n# Each row corresponds to a student, and each column corresponds to a subject: Math, Science, English\ngrades[1, 1] \u2190 85  # Student 1, Math\ngrades[1, 2] \u2190 90  # Student 1, Science\ngrades[1, 3] \u2190 88  # Student 1, English\n\ngrades[2, 1] \u2190 78  # Student 2, Math\ngrades[2, 2] \u2190 92  # Student 2, Science\ngrades[2, 3] \u2190 80  # Student 2, English\n\ngrades[3, 1] \u2190 90  # Student 3, Math\ngrades[3, 2] \u2190 85  # Student 3, Science\ngrades[3, 3] \u2190 87  # Student 3, English\n</code></pre>"},{"location":"8%20Programming/8.2%20ARRAYS/#section-4-using-arrays","title":"SECTION 4 | USING ARRAYS","text":"<p>Arrays are used for storing data that can be logically grouped together, such as the grades of students, temperature readings, or spatial coordinates.</p>"},{"location":"8%20Programming/8.3%20FILE%20HANDLING/","title":"8.3 FILE HANDLING","text":""},{"location":"8%20Programming/8.3%20FILE%20HANDLING/#83-file-handling","title":"8.3 | FILE HANDLING","text":""},{"location":"8%20Programming/8.3%20FILE%20HANDLING/#section-1-what-is-file-handling","title":"SECTION 1 | WHAT IS FILE HANDLING","text":"<p>File handling refers to the process by which a computer program interacts with files stored on a disk, enabling the reading, writing, and modification of data. Unlike data stored in standard arrays, which are temporary and reset every time a program restarts, files provide a way to preserve data persistently across multiple runs of an application. This is crucial for applications that require long-term data storage, such as user settings, game scores, or transaction logs.</p> <p>In programming languages like Python, file handling is straightforward yet powerful. Python uses simple commands to open, read, write, and close files, making it an ideal learning tool for students transitioning from temporary data storage in arrays to more permanent solutions. For example, to write data to a file, a Python program might open a file in write mode ('w'), write strings directly to the file, and then close it to ensure the data is saved:</p> Python<pre><code>with open('data.txt', 'w') as file:\n    file.write('Have a great day.')\n</code></pre> Text Only<pre><code>DECLARE DataToStore : STRING\nDataToStore \u2190 \"Have a great day.\"\n\nOPENFILE \"data.txt\" FOR WRITE\nWRITEFILE \"data.txt\", DataToStore\nCLOSEFILE \"data.txt\"\n</code></pre> <p>This code snippet opens data.txt (or creates it if it doesn't exist), writes a line of text, and automatically closes the file when done. The use of files allows data to be retained after the program closes, providing a durable means of storing information that can be retrieved and manipulated in subsequent program executions. This concept of persistent storage is fundamental for developing applications that interact with user data or require the retention of operational data over time.</p>"},{"location":"8%20Programming/8.3%20FILE%20HANDLING/#section-2-reading-from-a-text-file","title":"SECTION 2 | READING FROM A TEXT FILE","text":"<p>To read data from a file, you must first open it in READ mode. Once opened, you can read the data using:</p> Python<pre><code># Open the file \"data.txt\" in read mode and read from it\nwith open(\"data.txt\", \"r\") as file:\n    my_data = file.read()\n\n# Output the data read from the file\nprint(my_data)\n</code></pre> Text Only<pre><code>DECLARE MyData : STRING\nOPENFILE \"data.txt\" FOR READ\nREADFILE \"data.txt\", MyData\nCLOSEFILE \"data.txt\"\n</code></pre> <p>SECTION 3 | WRITING TO A TEXT FILE</p> <p>To write data to a file, open it in WRITE mode. Any existing content in the file will be erased. To write, use:</p> Python<pre><code># Open the file \"output.txt\" in write mode and write to it\nwith open(\"output.txt\", \"w\") as file:\n    file.write(\"Hello, world!\")\n</code></pre> Text Only<pre><code>DECLARE MyData : STRING\nMyData \u2190 \"Hello, world!\"\nOPENFILE \"output.txt\" FOR WRITE\nWRITEFILE \"output.txt\", MyData\nCLOSEFILE \"output.txt\"\n</code></pre>"},{"location":"8%20Programming/8.3%20FILE%20HANDLING/#section-4-closing-a-file","title":"SECTION 4 | CLOSING A FILE","text":"<p>After completing the read or write operations, it is good practice to close the file:</p> Text Only<pre><code>CLOSEFILE \"output.txt\"\n</code></pre>"},{"location":"8%20Programming/8.3%20FILE%20HANDLING/#section-5-copying-text-between-files","title":"SECTION 5 | COPYING TEXT BETWEEN FILES","text":"<p>Consider a scenario where you need to copy a line of text from one file to another:</p> Python<pre><code># Open \"FileA.txt\" for reading\nwith open(\"FileA.txt\", \"r\") as file_a:\n    line_of_text = file_a.read()  # Read all content from FileA\n\n# Open \"FileB.txt\" for writing\nwith open(\"FileB.txt\", \"w\") as file_b:\n    file_b.write(line_of_text)  # Write the content to FileB\n</code></pre> Text Only<pre><code>DECLARE LineOfText : STRING\nOPENFILE \"FileA.txt\" FOR READ\nOPENFILE \"FileB.txt\" FOR WRITE\nREADFILE \"FileA.txt\", LineOfText\nWRITEFILE \"FileB.txt\", LineOfText\nCLOSEFILE \"FileA.txt\"\nCLOSEFILE \"FileB.txt\"\n</code></pre>"},{"location":"8%20Programming/8.3%20FILE%20HANDLING/#section-6-readwrite-word-line-document","title":"SECTION 6 | READ/WRITE - WORD, LINE, DOCUMENT","text":"<p>Here, we explore the concepts of reading and writing by word, by line, and by the entire document, and how these operations are typically implemented in programming.</p> <p>Reading and Writing a Word When you read or write a word from a file, you are typically interacting with the smallest unit of meaningful text separated by spaces or punctuation. This level of granularity is useful for text analysis, such as counting word frequency or replacing specific words.</p> <p>READING A WORD</p> Python<pre><code>with open(\"file.txt\", \"r\") as file:\n    words = file.read().split()  # This reads the entire content and splits it by whitespace\n    for word in words:\n        print(word)  # This prints each word separately\n</code></pre> Text Only<pre><code>OPENFILE \"file.txt\" FOR READ\nDECLARE words : LIST OF STRING\nREADFILE \"file.txt\", words  // Assuming the entire file is read and split into words\nFOR EACH word IN words\n    OUTPUT word\nENDFOR\nCLOSEFILE \"file.txt\"\n</code></pre> <p>WRITING A WORD</p> Python<pre><code>with open(\"file.txt\", \"w\") as file:\n    word = \"Hello\"\n    file.write(word + \" \")  # Writes a single word to the file, followed by a space\n</code></pre> Text Only<pre><code>DECLARE word : STRING\nword \u2190 \"Hello\"\nOPENFILE \"file.txt\" FOR WRITE\nWRITEFILE \"file.txt\", word + \" \"  // Adds a space after the word\nCLOSEFILE \"file.txt\"\n</code></pre> <p>Reading and Writing a Line Lines represent a sequence of characters ending with a newline character (\\n). Handling data line by line is one of the most common forms of file manipulation, used for reading configuration files, logs, or any data structured into rows.</p> <p>READING A LINE</p> Python<pre><code>with open(\"file.txt\", \"r\") as file:\n    for line in file:\n        print(line.strip())  # `strip` removes the newline character at the end of each line\n</code></pre> Text Only<pre><code>OPENFILE \"file.txt\" FOR READ\nDECLARE line : STRING\nWHILE NOT EOF(\"file.txt\")  // Loop until the end of the file\n    READFILE \"file.txt\", line\n    OUTPUT line\nENDWHILE\nCLOSEFILE \"file.txt\"\n</code></pre> <p>WRITING A LINE</p> Python<pre><code>with open(\"file.txt\", \"w\") as file:\n    line = \"This is a line of text\\n\"\n    file.write(line)  # Writes the line including the newline character to delineate lines\n</code></pre> Text Only<pre><code>DECLARE line : STRING\nline \u2190 \"This is a line of text\\n\"\nOPENFILE \"file.txt\" FOR WRITE\nWRITEFILE \"file.txt\", line\nCLOSEFILE \"file.txt\"\n</code></pre> <p>Reading and Writing the Entire Document Sometimes, it's necessary to work with the entire content of a document at once, such as when loading configuration settings or processing small files where it's efficient to work with all the data in memory.</p> <p>READING THE DOCUMENT</p> Python<pre><code>with open(\"file.txt\", \"r\") as file:\n    content = file.read()  # Reads the entire file into a single string\n    print(content)\n</code></pre> Text Only<pre><code>OPENFILE \"file.txt\" FOR READ\nDECLARE content : STRING\nREADFILE \"file.txt\", content  // Reads the entire file into 'content'\nOUTPUT content\nCLOSEFILE \"file.txt\"\n</code></pre> <p>WRITING THE DOCUMENT</p> Python<pre><code>with open(\"file.txt\", \"w\") as file:\n    content = \"This is the entire content of the file.\"\n    file.write(content)  # Writes a large block of text to the file\n</code></pre> Text Only<pre><code>DECLARE content : STRING\ncontent \u2190 \"This is the entire content of the file.\"\nOPENFILE \"file.txt\" FOR WRITE\nWRITEFILE \"file.txt\", content\nCLOSEFILE \"file.txt\"\n</code></pre> <p>MULTIPLE CHOICE QUESTIONS</p> <p>1: What does the OPENFILE command do in file handling? A) Closes the file B) Reads data from the file C) Opens the file for reading, writing, or both D) Deletes the file</p> <p>2: When opening a file for writing using OPENFILE \"data.txt\" FOR WRITE, what happens if \"data.txt\" already exists? A) The file is deleted and a new empty file is created. B) The file cannot be opened unless it is empty. C) Data will be appended to the existing data. D) The file is opened normally with no changes to existing data.</p> <p>3: Which command reads data from an open file into a variable? A) OPENFILE B) READFILE C) WRITEFILE D) CLOSEFILE</p> <p>4: Why is it important to close a file after operations are completed? A) To save the data written to the file B) To free up system resources C) Both A and B D) Closing a file is optional and does not impact the system or data.</p> <p>5: In file handling, what does EOF stand for, and why is it significant? A) End Of File, it indicates that there is no more data to read from the file. B) Execution Of File, it indicates that the file is currently being executed. C) Each Open File, a reference to all open files in a program. D) Error On File, an error message that occurs when a file cannot be accessed.</p> <p>6: Which file mode should be used if you need to both read from and write to the same file without deleting its contents? A) READ B) WRITE C) APPEND D) READ/WRITE \u200b 7: What is a potential consequence of not closing a file in a program? A) The data might not be properly saved to the file. B) The program might use more memory than necessary. C) Other programs might not be able to open the file. D) All of the above.</p> <p>8: How can you ensure data is read one line at a time from a file? A) Use READFILE ,  and specify you want lines. B) Read the entire file and split the data into lines in the program. C) Use a loop to read until EOF, capturing data line by line. D) It's not possible to read data one line at a time. <p>9: What is the correct way to write the string \"Hello World\" to a new file called \"greetings.txt\"? A) OPENFILE \"greetings.txt\" FOR WRITE then WRITEFILE \"Hello World\" B) WRITEFILE \"greetings.txt\", \"Hello World\" without opening the file. C) OPENFILE \"greetings.txt\" FOR WRITE then WRITEFILE \"greetings.txt\", \"Hello World\" then CLOSEFILE \"greetings.txt\" D) WRITEFILE \"greetings.txt\", \"Hello World\" then CLOSEFILE \"greetings.txt\"</p> <p>10: Which of the following is true about the WRITEFILE command? A) It can be used without opening the file first. B) It appends the data to the end of the file by default. C) It overwrites the existing content unless the file is opened in append mode. D) It reads data from the file and writes it to another file.</p>"},{"location":"8%20Programming/8.3%20FILE%20HANDLING/#section-7-file-handling-with-spreadsheets-csv-files","title":"SECTION 7 | FILE HANDLING WITH SPREADSHEETS / CSV FILES","text":"<p>CSV (Comma Separated Values) files are commonly used to store tabular data. These files are straightforward to read from and write to because their data is separated by commas, making parsing simple. In computer programming, handling CSV files efficiently can be crucial for data processing tasks such as database uploads, data analysis, and report generation. Here, we'll explore how to perform basic operations such as reading, writing, appending, and modifying data in CSV files.</p> <p>READING FROM A CSV FILE</p> Python<pre><code>import csv\n\nwith open('data.csv', 'r', newline='') as file:\n    reader = csv.reader(file)\n    for row in reader:\n        print(row)  # Each row is a list of values\n</code></pre> Text Only<pre><code>OPENFILE \"data.csv\" FOR READ\nDECLARE row : STRING\nWHILE NOT EOF(\"data.csv\")\n    READFILE \"data.csv\", row\n    OUTPUT row  // Prints each row of the CSV file\nENDWHILE\nCLOSEFILE \"data.csv\"\n</code></pre> <p>WRITING TO A CSV FILE</p> Python<pre><code>import csv\n\nwith open('new_data.csv', 'w', newline='') as file:\n    writer = csv.writer(file)\n    writer.writerow(['Name', 'Age', 'Location'])  # Write a header row\n</code></pre> Text Only<pre><code>OPENFILE \"new_data.csv\" FOR WRITE\nDECLARE dataRow : STRING\ndataRow \u2190 \"Name,Age,Location\"\nWRITEFILE \"new_data.csv\", dataRow\nCLOSEFILE \"new_data.csv\"\n</code></pre> <p>APPENDING A CSV FILE</p> <p>Appending to a CSV file involves adding new rows of data without overwriting existing data.</p> Python<pre><code>OPENFILE \"data.csv\" FOR APPEND\nDECLARE newRow : STRING\nnewRow \u2190 \"John,30,New York\"\nWRITEFILE \"data.csv\", newRow\nCLOSEFILE \"data.csv\"\n</code></pre> Text Only<pre><code>import csv\n\nwith open('data.csv', 'a', newline='') as file:\n    writer = csv.writer(file)\n    writer.writerow(['John', 30, 'New York'])  # Append a new row\n</code></pre> <p>MODIFYING A CSV FILE</p> <p>Modifying a CSV file generally involves reading the existing data, making changes, and then writing the data back to the file.</p> Python<pre><code>import csv\n\n# Read all data\ndata = []\nwith open('data.csv', 'r', newline='') as file:\n    reader = csv.reader(file)\n    for row in reader:\n        data.append(row)\n\n# Modify data\nfor row in data:\n    if 'OldLocation' in row:\n        index = row.index('OldLocation')\n        row[index] = 'NewLocation'\n\n# Write data back\nwith open('data.csv', 'w', newline='') as file:\n    writer = csv.writer(file)\n    for row in data:\n        writer.writerow(row)\n</code></pre> Text Only<pre><code>import csv\n\n# Read all data\ndata = []\nwith open('data.csv', 'r', newline='') as file:\n    reader = csv.reader(file)\n    for row in reader:\n        data.append(row)\n\n# Modify data\nfor row in data:\n    if 'OldLocation' in row:\n        index = row.index('OldLocation')\n        row[index] = 'NewLocation'\n\n# Write data back\nwith open('data.csv', 'w', newline='') as file:\n    writer = csv.writer(file)\n    for row in data:\n        writer.writerow(row)\n</code></pre> <p>EXAMINATION STYLE QUESTIONS</p> <p>1: What does the following block of pseudocode do?</p> <p>DECLARE FileReader : FILE OPENFILE \"journal.txt\" FOR READ DECLARE LineCount : INTEGER LineCount \u2190 0 DECLARE Line : STRING</p> <p>READFILE \"journal.txt\", Line WHILE NOT Line = \"\"   LineCount \u2190 LineCount + 1   READFILE \"journal.txt\", Line ENDWHILE</p> <p>OUTPUT \"Number of lines in the file: \", LineCount CLOSEFILE \"journal.txt\"</p> <p>A) Counts the number of words in journal.txt B) Counts the number of characters in journal.txt C) Counts the number of lines in journal.txt D) Copies the content of journal.txt to another file</p> <p>2: Write pseudocode to append the text \"Remember to subscribe!\" to the end of an existing text file named \"notes.txt\".</p> <p>*3: Examine the following pseudocode and explain what it accomplishes. *OPENFILE \"report.txt\" FOR WRITE FOR i FROM 1 TO 100   WRITEFILE \"report.txt\", \"Line \", i ENDFOR CLOSEFILE \"report.txt\"</p> <p>*4: Identify the error in the following pseudocode that intends to read each word from data.txt and print it. *OPENFILE \"data.txt\" FOR READ DECLARE Word : STRING</p> <p>READFILE \"data.txt\", Word WHILE NOT Word = \"\"   OUTPUT Word   READFILE \"data.txt\", Word ENDWHILE</p> <p>CLOSEFILE \"data.txt\"</p> <p>5: Given the scenario where a student needs to save their daily expenses into a file named \"expenses.txt\", write pseudocode that allows the user to enter their expenses one at a time and save each entry on a new line in the file until the user types \"stop\".</p>"}]}